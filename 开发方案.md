你好！48小时黑客松，时间非常宝贵。你的策划案非常完整，但功能点很多。作为Unity程序，你的首要任务是搭建一个**“能跑起来的最小可行产品（MVP）”**，然后再在上面“添肉”。

基于你的策划案和需求，我为你梳理了一个高优先级的**“关键路径”开发顺序**。请严格按照这个顺序执行，这能最大程度保证你们在48小时内有一个可演示的核心玩法。

------



## “野朋友联盟” 48小时开发关键路径



这个顺序的原则是：**先核心战斗，再外围系统，最后才是AI亮点。**



### 阶段一：搭建“能打起来”的核心战斗场景 (预计 8-10 小时)



目标：在场景中手动放置我方和敌方单位，点击“开始”后，它们能自动寻找敌人、攻击、受伤、死亡。

1. **创建核心数据结构 (ScriptableObject)**
   - `AnimalData (ScriptableObject)`：用来存储策划案中的动物属性（费用、HP、ATK、DEF、ASP、Range等）。
   - `EnemyData (ScriptableObject)`：同上，存储敌人的属性。
   - **为什么？** 这能让你和策划（如果有的话）快速修改数值，而不用动代码。
2. **创建单位Prefab (Prefab)**
   - `Unit_Base (Prefab)`：创建一个基础单位预制体（用Cube或Sphere占位即可）。
   - 挂载 `UnitController.cs` 脚本。
   - `UnitController.cs` 必须包含：
     - `public AnimalData data;` (或 `EnemyData`)
     - `int currentHP;`
     - `Transform target;`
     - `TakeDamage(int damage)`: 实现策划案中的伤害公式 `max(ATK - DEF, 0)`。
     - `Die()`: 死亡时自我销毁。
3. **实现自动战斗逻辑 (Core AI)**
   - 在 `UnitController.cs` 的 `Update()` 中：
   - **索敌：** 如果 `target == null`，就寻找范围内最近的敌人（用 `Physics.OverlapSphere` 或简单的标签查找）。
   - **移动：** 如果有目标但不在攻击范围 (`Range`) 内，就朝目标移动。
   - **攻击：** 如果在攻击范围内，就根据 `ASP` (行动频率) 计时，时间到了就调用 `target.TakeDamage(data.ATK)`。
4. **创建游戏管理器 (Singleton)**
   - `GameManager.cs (Singleton)`：管理游戏状态。
   - 创建 `enum GameState { Preparation, Battle }`。
   - **“开始对战”按钮 (UI)**：创建一个按钮，点击后调用 `GameManager.StartBattle()`。
   - `StartBattle()`:
     - 将 `GameManager.state` 设为 `Battle`。
     - 通知所有 `UnitController` (例如，设置一个 `bool canFight = true`) 开始执行它们的 `Update()` 战斗逻辑。
5. **搭建波次管理器 (Wave Spawner)**
   - `WaveManager.cs`：
   - `SpawnWave(int waveIndex)`: 根据策划案（或你硬编码的数据）在指定位置生成敌人Prefab。
   - 让“开始对战”按钮同时调用 `WaveManager.SpawnWave(currentWave)`。
6. **【阶段一测试】**
   - 在场景里**手动**拖入几个你做好的 `Animal_Prefab`（并设置好它们的 `AnimalData`），在敌人出生点放好。
   - 点击“开始对战”按钮。
   - **验收标准：** 动物和敌人自动开打，一方全部死亡，战斗结束。

------



### 阶段二：实现“准备阶段”的交互 (预计 10-12 小时)



目标：实现从商店购买动物到备战席，再从备战席拖拽上场的核心交互。

1. **搭建网格系统 (Grid System)**
   - `GridManager.cs`：在场景中（棋盘区域）生成一个5x4或6x5的“格子”系统。每个格子是一个 `GridSlot.cs` (可以是`MonoBehaviour`或纯数据)，它需要知道自己的位置、是否被占用。
2. **搭建UI：商店与备战席**
   - **商店 (UI)**：按照图示，在底部创建6个 `ShopSlot_UI.cs`。
   - **备战席 (UI)**：按照图示，在左侧创建6个 `BenchSlot_UI.cs`。
3. **实现商店逻辑 (Shop System)**
   - `ShopManager.cs`：
   - `RefreshShop()`: 从 `ScriptableObject` 列表中随机选4个动物（策划案要求4个，图上是6个，**请和团队确认！** 按策划案的4个来），显示在 `ShopSlot_UI` 上。
   - **资源系统 (Gold System)**：`PlayerStats.cs (Singleton)`，包含 `int currentGold`。
   - **购买逻辑**：点击 `ShopSlot_UI`，检查 `PlayerStats.currentGold` 是否足够。
     - 如果足够，扣钱，然后**在 `BenchSlot_UI` 的一个空位上实例化一个“动物棋子UI”**（代表你拥有了这个棋子）。
4. **实现拖拽系统 (Drag & Drop)**
   - 这是**最关键**的交互。你需要实现：
   - **从备战席 -> 棋盘：**
     - 给“动物棋子UI”添加 `IDragHandler` 等接口。
     - `OnBeginDrag`：在鼠标位置生成一个临时的棋子模型。
     - `OnEndDrag`：用射线检测鼠标落点。
     - 如果落点是 `GridSlot` 且未被占用：在 `GridSlot` 的世界坐标位置**实例化 `Unit_Base (Prefab)`**，并销毁备战席的UI。
     - 如果落点无效：放回备战席。
   - **棋盘 -> 棋盘 (调位)**
   - **棋盘 -> 备战席 (撤回)**
   - **棋盘/备战席 -> 商店 (出售)**：检测是否拖拽到了“商店区域”，如果是，销毁单位并 `PlayerStats.AddGold(1)`。
5. **【阶段二测试】**
   - **验收标准：**
     1. 可以从商店花钱买动物到备战席。
     2. 可以从备战席拖拽动物到棋盘上。
     3. 可以拖拽棋盘上的动物调换位置。
     4. 可以把动物拖回商店卖掉。
     5. 点击“开始对战”，你放上去的动物和生成的敌人开打。

------



### 阶段三：实现“游戏循环”与核心系统 (预计 8-10 小时)



目标：让游戏能完整地从第1波打到第10波，并实现升星和羁绊。

1. **完善游戏循环 (Game Loop)**
   - `GameManager.cs` 需要检测战斗结束（一方单位全灭）。
   - `OnBattleEnd(bool playerWon)`:
     - `if (!playerWon)`: 扣除玩家生命 `PlayerStats.TakeDamage(1)`。检查是否游戏失败。
     - `if (playerWon)`: 结算奖励 `PlayerStats.AddGold(3)`。检查是否已是第10波（游戏胜利）。
     - **重置战斗**：销毁所有剩余的敌我单位（或从棋盘移回备战席）。
     - `WaveManager.currentWave++`。
     - 调用 `ShopManager.RefreshShop()`。
     - `GameManager.state` 切换回 `Preparation`。
     - **注意：** 策划案中“AI问答”是在这里强制触发的。见阶段四。
2. **实现升星系统 (Star-Up)**
   - 这是自走棋的核心。
   - **时机：** 在**购买时**或**拖拽结束时**（拖到备战席或棋盘时）触发检查。
   - **逻辑：**
     - 扫描**备战席**和**棋盘**上的所有同名单位。
     - `FindUnits(string animalName, int starLevel)`
     - 如果发现3个1星同名：销毁这3个单位，在最后一个单位的位置生成1个2星的同名单位（需要2星的Prefab或数据）。
     - 如果发现3个2星同名：同上，合成1个3星。
3. **实现羁绊系统 (Synergy System)**
   - `SynergyManager.cs`：
   - 在每次**单位上场**或**下场**时调用 `UpdateSynergies()`。
   - `UpdateSynergies()`:
     - 遍历**棋盘上**（注意：不是备战席）的所有单位。
     - 用 `Dictionary<SynergyType, int>` 统计每个“生态群系”和“生态职能”的数量。
     - 根据策划案的规则（如“水生(2)”），激活羁绊。
     - **应用Buff：** `UnitController.cs` 需要有 `AddBuff(BuffData buff)` 和 `ClearBuffs()` 方法。在战斗开始前，`SynergyManager` 遍历所有单位，给它们加上应有的Buff。
     - **UI显示：** 在UI上更新激活的羁绊图标和数量。
4. **【阶段三测试】**
   - **验收标准：**
     1. 买3个青蛙，它们自动合成了2星青蛙。
     2. 上场2个“水生”单位（如青蛙、鲤鱼），UI显示“水生(2)”激活，且战斗中单位获得了屏障。
     3. 能完整地打完一波，结算，然后开始下一波的准备。

------



### 阶段四：实现“AI问答”亮点功能 (预计 6-8 小时)



目标：实现策划案中的核心亮点——波次结束后的动态问答。

1. **创建问答UI (UI Panel)**
   - 创建一个全屏UI面板 `Quiz_Panel`，包含问题、三个选项（卡牌样式）、确认按钮。
2. **“伪”AI数据 (Hardcode Data)**
   - **放弃离线AI生成！** 48小时内绝对来不及。
   - 创建一个 `QuizData.json` 文件，或者 `QuizQuestion (ScriptableObject)`。
   - **硬编码** 10-15道题目，每道题包含：`animalName` (对应哪个动物), `questionText`, `options` (选项数组), `correctAnswerIndex`, `difficulty` (1-9)。
3. **实现问答管理器 (Quiz Manager)**
   - `QuizManager.cs`：
   - `ShowQuiz()`:
     - 从 `QuizData` 中**随机**选3道题。
     - 显示 `Quiz_Panel`，并把3道题的数据（动物名、难度）显示在3张卡牌上。
   - `SelectQuestion(int index)`: 玩家点击一道题，显示该题的详细问题和选项。
   - `SubmitAnswer(int answerIndex)`:
     - 检查答案是否正确。
     - **应用奖惩：**
       - **答对：** `ApplyBuffToAnimal(animalName, "ATK_Buff_10_Percent")`。你需要一个 `BuffManager` 来存储这些临时的、局内的Buff。
       - **答错：** `ApplyBuffToAnimal(animalName, "HP_Debuff_5_Percent_Next_Round")`。
     - 隐藏 `Quiz_Panel`。
     - 通知 `GameManager`：“问答结束，可以进入下一波的准备阶段了”。
4. **嵌入游戏循环**
   - 修改 `GameManager` 的 `OnBattleEnd()` 逻辑。
   - 在结算奖励后，**强制调用 `QuizManager.ShowQuiz()`**。
   - `GameManager` 必须等待 `QuizManager` 隐藏后，才能将状态切换回 `Preparation`。
5. **【阶段四测试】**
   - **验收标准：** 打完一波后，问答界面弹出。选择一道题，回答。答对或答错后，在下一场战斗中，对应的动物棋子属性（HP或ATK）发生变化。

------



### 阶段五：收尾与打磨 (剩余时间)



如果以上都完成了，你还有时间，再去做这些：

1. **实现技能 (Skills)：** 在 `UnitController.cs` 中添加“生态能量(Mana)”系统。Mana满时释放技能（先实现1-2个简单的，比如青蛙的眩晕、鲤鱼的护盾）。
2. **实现人口升级 (Level Up)：** 添加一个“提升终端等级”的UI按钮，点击花钱，提升你的人口上限。
3. **美术资源替换：** 把你的Cube和Sphere换成美术给的2D Spine动画或图片。
4. **音效：** 添加BGM和关键音效（点击、购买、攻击、胜利）。
5. **敌人多样化：** 实现“废弃桶怪”的死亡泄露（在`Die()`中生成一个Debuff区域）。

------



### 48小时黑客松Unity开发箴言



- **放弃完美，追求完成：** 用最丑的UI，最简单的方块，先把核心循环跑通。
- **多用Singleton：** 在黑客松中，`GameManager.Instance.PlayerGold` 这样的写法比复杂的依赖注入快100倍。
- **硬编码就是力量：** 不要去写复杂的编辑器工具或AI生成管线。把敌人波次、商店概率、问答题目全部硬编码在代码或JSON里。
- **版本控制 (Git)：** **从第1分钟开始就用Git！** 每次完成一个小功能（比如“实现索敌”）就 `git commit`。这是你的救命稻草。
- **常量优先 (const / static readonly)：** 比如 "Enemy" 标签， "Water" 羁绊名，都用常量定义，防止拼写错误。

祝你们黑客松顺利，做出亮点！加油！